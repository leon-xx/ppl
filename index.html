<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™¾æ•°è¡¨æ‹¼æ‹¼ä¹</title>
    <style>
    /* å…¨å±€æ ·å¼ */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Arial Rounded MT Bold', 'Microsoft YaHei', sans-serif;
    }

    body {
        background-color: #f0f8ff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 20px;
        background-image: linear-gradient(to bottom, #a1c4fd, #c2e9fb);
    }

    .game-container {
        max-width: 1200px;
        width: 100%;
        background-color: white;
        border-radius: 20px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    /* å¤´éƒ¨æ ·å¼ */
    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 3px dashed #ffb6c1;
    }

    .score-container, .timer-container {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 24px;
        font-weight: bold;
        background-color: #fff0f5;
        padding: 10px 15px;
        border-radius: 15px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .title h1 {
        color: #ff6b88;
        text-align: center;
        font-size: 2.5rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }

    .emoji {
        font-size: 1.3em;
        margin: 0 5px;
    }

    /* æ¸¸æˆåŒºåŸŸæ ·å¼ */
    .game-area {
        position: relative;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-top: 20px;
    }

    .number-grid-container, .pieces-container {
        flex: 1;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    /* ç»Ÿä¸€æ ¼å­å¤§å°è§„åˆ™ */
    :root {
        --cell-size: 40px; /* å®šä¹‰ç»Ÿä¸€çš„å•å…ƒæ ¼å¤§å° */
    }

    .number-grid {
        position: relative;
        width: 400px;
        height: 400px;
        display: grid;
        grid-template-columns: repeat(10, 40px);
        grid-template-rows: repeat(10, 40px);
        gap: 0;
        background-color: #f0f0f0;
        border: 2px solid #333;
        border-radius: 5px;
        user-select: none;
    }

    .grid-cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background-color: #f9f9f9;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        border: 1px solid #ddd;
        transition: all 0.3s ease;
    }

    .grid-cell.highlight {
        background-color: #e6f7ff;
        box-shadow: inset 0 0 5px rgba(0, 123, 255, 0.5);
    }

    .pieces {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 15px;
        width: 100%;
        min-height: 500px;
        padding: 15px;
        background-color: #f5f5f5;
        border-radius: 15px;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        overflow-y: auto;
    }

    .piece {
        position: relative;
        display: grid;
        cursor: grab;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        z-index: 1;
        margin: 5px;
        user-select: none; /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡æœ¬ */
    }

    .piece:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        z-index: 2;
    }

    .piece.dragging {
        opacity: 0.8;
        cursor: grabbing;
    }

    /* ä¿®å¤ç™¾æ•°è¡¨å†…æ‹¼å›¾å¯æ‹–æ‹½çš„æ ·å¼ */
    .number-grid .piece {
        position: absolute; /* ç¡®ä¿åœ¨ç½‘æ ¼ä¸­ä½ç½®æ­£ç¡® */
        cursor: grab;
    }

    .number-grid .piece:hover {
        transform: scale(1.03); /* æ‚¬åœæ—¶è½»å¾®æ”¾å¤§ï¼Œä½†ä¸è¦å¤ªå¤§ */
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        z-index: 10; /* ç¡®ä¿åœ¨å…¶ä»–å…ƒç´ ä¹‹ä¸Š */
    }

    .number-grid .piece.dragging {
        cursor: grabbing;
        z-index: 100; /* æ‹–åŠ¨æ—¶ç½®äºæœ€ä¸Šå±‚ */
    }

    .piece-cell {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    /* æ§åˆ¶åŒºåŸŸæ ·å¼ */
    .controls {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
    }

    .game-button {
        padding: 12px 24px;
        font-size: 18px;
        font-weight: bold;
        border: none;
        border-radius: 50px;
        background: linear-gradient(to right, #ff758c, #ff7eb3);
        color: white;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
    }

    .game-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        background: linear-gradient(to right, #ff5277, #ff65a3);
    }

    .game-button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
    }

    /* çƒŸèŠ±æ•ˆæœ */
    .fireworks {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
        display: none;
    }

    .firework {
        position: absolute;
        width: 5px;
        height: 5px;
        border-radius: 50%;
        box-shadow: 0 0 10px 2px;
        animation: firework-animation 2s ease-out;
        transform-origin: center;
    }

    @keyframes firework-animation {
        0% {
            transform: scale(0);
            opacity: 1;
        }
        50% {
            opacity: 1;
        }
        100% {
            transform: scale(15);
            opacity: 0;
        }
    }

    /* å®Œæˆæ¸¸æˆåçš„å¼¹å‡ºæ¨¡æ€æ¡† */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        align-items: center;
        justify-content: center;
    }

    .modal-content {
        background-color: white;
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 5px 30px rgba(0, 0, 0, 0.3);
        animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    @keyframes pop-in {
        0% {
            transform: scale(0.5);
            opacity: 0;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .modal h2 {
        color: #ff6b88;
        font-size: 2.5rem;
        margin-bottom: 20px;
    }

    .modal p {
        font-size: 1.2rem;
        margin-bottom: 15px;
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
        .game-area {
            flex-direction: column;
        }
        
        .header {
            flex-direction: column;
            gap: 15px;
        }
        
        .controls {
            flex-direction: column;
            align-items: center;
        }
        
        .title h1 {
            font-size: 1.8rem;
        }
        
        :root {
            --cell-size: 30px; /* åœ¨å°å±å¹•ä¸Šå‡å°å•å…ƒæ ¼å¤§å° */
        }
    }

    /* æ‹¼å›¾é¢„è§ˆå®¹å™¨æ ·å¼ */
    .piece-preview {
        position: absolute;
        z-index: 10;
        pointer-events: none;
        transition: all 0.15s ease-out;
        background-color: rgba(255, 255, 255, 0.1);
        box-shadow: 0 0 15px rgba(100, 100, 255, 0.5);
        border-radius: 4px;
    }

    /* é¢„è§ˆå•å…ƒæ ¼æ ·å¼ */
    .preview-cell {
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        border-radius: 4px;
        transition: all 0.2s ease;
        font-size: 18px;
    }

    /* æ­£ç¡®æ”¾ç½®æ—¶çš„è„‰å†²åŠ¨ç”» */
    .preview-cell.correct {
        animation: pulseCorrect 1.5s infinite;
    }

    /* ä¸æ­£ç¡®æ”¾ç½®æ—¶çš„è„‰å†²åŠ¨ç”» */
    .preview-cell.incorrect {
        animation: pulseIncorrect 1.5s infinite;
    }

    /* åŠ¨ç”»å…³é”®å¸§ - æ­£ç¡®æ”¾ç½® */
    @keyframes pulseCorrect {
        0% { box-shadow: 0 0 0 0 rgba(50, 205, 50, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(50, 205, 50, 0); }
        100% { box-shadow: 0 0 0 0 rgba(50, 205, 50, 0); }
    }

    /* åŠ¨ç”»å…³é”®å¸§ - ä¸æ­£ç¡®æ”¾ç½® */
    @keyframes pulseIncorrect {
        0% { box-shadow: 0 0 0 0 rgba(255, 165, 0, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(255, 165, 0, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 165, 0, 0); }
    } 
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="score-container">
                <span class="emoji">ğŸ®</span>
                <span>åˆ†æ•°ï¼š</span>
                <span id="score">0</span>
            </div>
            <div class="title">
                <h1>ç™¾æ•°è¡¨æ‹¼æ‹¼ä¹ <span class="emoji">ğŸ¯</span></h1>
            </div>
            <div class="timer-container">
                <span class="emoji">â±ï¸</span>
                <span>æ—¶é—´ï¼š</span>
                <span id="timer">00:00</span>
            </div>
        </div>
        
        <div class="game-area">
            <div class="number-grid-container">
                <div id="numberGrid" class="number-grid"></div>
            </div>
            
            <div class="pieces-container">
                <h3>æ‹–åŠ¨å³è¾¹çš„æ‹¼å›¾åˆ°å·¦è¾¹æ­£ç¡®çš„ä½ç½® <span class="emoji">ğŸ‘ˆ</span></h3>
                <div id="pieces" class="pieces"></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startButton" class="game-button">å¼€å§‹æ¸¸æˆ <span class="emoji">ğŸš€</span></button>
            <button id="resetButton" class="game-button">é‡æ–°å¼€å§‹ <span class="emoji">ğŸ”„</span></button>
            <button id="musicToggle" class="game-button">éŸ³ä¹å¼€/å…³ <span class="emoji">ğŸµ</span></button>
        </div>
    </div>
    
    <div id="fireworks" class="fireworks"></div>
    <div id="congratsModal" class="modal">
        <div class="modal-content">
            <h2>æ­å–œä½ ! <span class="emoji">ğŸ‰</span></h2>
            <p>ä½ æˆåŠŸå®Œæˆäº†ç™¾æ•°è¡¨æ‹¼å›¾!</p>
            <p>ä½ çš„å¾—åˆ†: <span id="finalScore"></span></p>
            <p>ç”¨æ—¶: <span id="finalTime"></span></p>
            <button id="playAgainButton" class="game-button">å†ç©ä¸€æ¬¡ <span class="emoji">ğŸ®</span></button>
        </div>
    </div>
    
    <audio id="backgroundMusic" loop>
        <source src="assets/sounds/background_music.mp3" type="audio/mp3">
    </audio>
    <audio id="correctSound">
        <source src="assets/sounds/correct.mp3" type="audio/mp3">
    </audio>
    <audio id="successSound">
        <source src="assets/sounds/success.mp3" type="audio/mp3">
    </audio>
    
    <script>
    // æ¸¸æˆçŠ¶æ€å˜é‡
    let gameState = {
        score: 0,
        timer: 0,
        timerInterval: null,
        isGameStarted: false,
        isGameCompleted: false,
        musicOn: false,
        grid: [], // å­˜å‚¨å®Œæ•´ç™¾æ•°è¡¨
        pieces: [], // å­˜å‚¨åˆ‡å‰²åçš„æ–¹å—
        placedPieces: {}, // å­˜å‚¨å·²æ”¾ç½®çš„æ–¹å—ä¿¡æ¯ï¼Œä»¥ç½‘æ ¼ä½ç½®ä¸ºé”®
        correctPlacements: 0, // æ­£ç¡®æ”¾ç½®çš„æ–¹å—æ•°
        totalPieces: 0, // æ€»æ–¹å—æ•°
        currentDraggingPiece: null, // å½“å‰æ­£åœ¨æ‹–åŠ¨çš„æ‹¼å›¾
        previewCells: [], // å­˜å‚¨é¢„è§ˆå•å…ƒæ ¼
        previewElement: null // é¢„è§ˆå…ƒç´ 
    };

    // DOM å…ƒç´ 
    const elements = {
        numberGrid: document.getElementById('numberGrid'),
        pieces: document.getElementById('pieces'),
        score: document.getElementById('score'),
        timer: document.getElementById('timer'),
        startButton: document.getElementById('startButton'),
        resetButton: document.getElementById('resetButton'),
        musicToggle: document.getElementById('musicToggle'),
        fireworks: document.getElementById('fireworks'),
        congratsModal: document.getElementById('congratsModal'),
        finalScore: document.getElementById('finalScore'),
        finalTime: document.getElementById('finalTime'),
        playAgainButton: document.getElementById('playAgainButton'),
        backgroundMusic: document.getElementById('backgroundMusic'),
        correctSound: document.getElementById('correctSound'),
        successSound: document.getElementById('successSound')
    };

    // é¢œè‰²æ•°ç»„ï¼Œç”¨äºæ–¹å—é¢œè‰²
    const colors = [
        '#FF9AA2', '#FFB7B2', '#FFDAC1', '#E2F0CB', '#B5EAD7',
        '#C7CEEA', '#B5D8EB', '#D7B9D5', '#F4ACBF', '#9ADCFF',
        '#FFD166', '#EF476F', '#06D6A0', '#118AB2', '#073B4C'
    ];

    // åˆå§‹åŒ–æ¸¸æˆ
    function initGame() {
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        elements.startButton.addEventListener('click', startGame);
        elements.resetButton.addEventListener('click', resetGame);
        elements.musicToggle.addEventListener('click', toggleMusic);
        elements.playAgainButton.addEventListener('click', resetGame);
        
        // åˆ›å»ºç™¾æ•°è¡¨æ ¼å­
        createNumberGrid();
        
        // åˆå§‹åŒ–éŸ³ä¹å’ŒéŸ³æ•ˆ
        setupAudio();
        
        // å…¨å±€æ‹–æ‹½äº‹ä»¶
        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });
        
        // å…¨å±€æ‹–æ‹½ç»“æŸäº‹ä»¶
        document.addEventListener('dragend', function(e) {
            clearPiecePreview();
            gameState.currentDraggingPiece = null;
        });
        
        // è®¾ç½®ç½‘æ ¼åŒºåŸŸçš„æ‹–æ‹½å’Œæ”¾ç½®äº‹ä»¶
        elements.numberGrid.addEventListener('dragover', handleDragOver);
        elements.numberGrid.addEventListener('drop', handleDrop);
        
        // è®¾ç½®æ‹¼å›¾åŒºåŸŸçš„æ‹–æ‹½å’Œæ”¾ç½®äº‹ä»¶
        elements.pieces.addEventListener('dragover', (e) => e.preventDefault());
        elements.pieces.addEventListener('drop', handleDrop);
        
        // åˆå§‹åŒ–é¢„è§ˆå…ƒç´ ä¸ºnull
        gameState.previewElement = null;
    }

    // åˆ›å»ºç™¾æ•°è¡¨æ ¼å­ï¼ˆç©ºç™½ï¼Œå¾…æ‹¼å›¾ï¼‰
    function createNumberGrid() {
        elements.numberGrid.innerHTML = '';
        gameState.grid = [];
        
        for (let row = 0; row < 10; row++) {
            const rowArray = [];
            for (let col = 0; col < 10; col++) {
                const number = row * 10 + col + 1;
                
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                cell.dataset.number = number;
                
                // æ•°å­—éšè—ï¼Œåªæ˜¾ç¤ºç©ºç™½æ ¼å­
                // cell.textContent = number;
                
                cell.addEventListener('dragenter', handleDragEnter);
                cell.addEventListener('dragleave', handleDragLeave);
                
                elements.numberGrid.appendChild(cell);
                rowArray.push({
                    element: cell,
                    number: number,
                    filled: false,
                    pieceId: null // å­˜å‚¨æ”¾ç½®åœ¨æ­¤æ ¼å­ä¸Šçš„æ‹¼å›¾ID
                });
            }
            gameState.grid.push(rowArray);
        }
    }

    // å¼€å§‹æ¸¸æˆ
    function startGame() {
        if (gameState.isGameStarted) return;
        
        resetGame();
        gameState.isGameStarted = true;
        elements.startButton.disabled = true;
        
        // ç”Ÿæˆæ‹¼å›¾ç¢ç‰‡
        generatePieces();
        
        // å¼€å§‹è®¡æ—¶å™¨
        startTimer();
        
        // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
        if (!gameState.musicOn) {
            toggleMusic();
        }
    }

    // é‡ç½®æ¸¸æˆ
    function resetGame() {
        // åœæ­¢è®¡æ—¶å™¨
        clearInterval(gameState.timerInterval);
        
        // é‡ç½®æ¸¸æˆçŠ¶æ€
        gameState.score = 0;
        gameState.timer = 0;
        gameState.isGameStarted = false;
        gameState.isGameCompleted = false;
        gameState.correctPlacements = 0;
        gameState.totalPieces = 0;
        gameState.placedPieces = {};
        gameState.currentDraggingPiece = null;
        gameState.previewCells = [];
        
        // ç§»é™¤é¢„è§ˆå…ƒç´ 
        if (gameState.previewElement) {
            if (gameState.previewElement.parentNode) {
                gameState.previewElement.parentNode.removeChild(gameState.previewElement);
            }
            gameState.previewElement = null;
        }
        
        // æ›´æ–°UI
        elements.score.textContent = '0';
        elements.timer.textContent = '00:00';
        elements.congratsModal.style.display = 'none';
        elements.fireworks.innerHTML = '';
        elements.fireworks.style.display = 'none';
        elements.startButton.disabled = false;
        
        // é‡æ–°åˆ›å»ºç™¾æ•°è¡¨å’Œæ‹¼å›¾åŒº
        createNumberGrid();
        elements.pieces.innerHTML = '';
        gameState.pieces = [];
    }

    // å¯åŠ¨è®¡æ—¶å™¨
    function startTimer() {
        clearInterval(gameState.timerInterval);
        gameState.timer = 0;
        updateTimerDisplay();
        
        gameState.timerInterval = setInterval(() => {
            gameState.timer++;
            updateTimerDisplay();
        }, 1000);
    }

    // æ›´æ–°è®¡æ—¶å™¨æ˜¾ç¤º
    function updateTimerDisplay() {
        const minutes = Math.floor(gameState.timer / 60).toString().padStart(2, '0');
        const seconds = (gameState.timer % 60).toString().padStart(2, '0');
        elements.timer.textContent = `${minutes}:${seconds}`;
    }

    // éŸ³ä¹å’ŒéŸ³æ•ˆè®¾ç½®
    function setupAudio() {
        // é¢„åŠ è½½éŸ³æ•ˆ
        elements.correctSound.load();
        elements.successSound.load();
        elements.backgroundMusic.load();
    }

    // åˆ‡æ¢èƒŒæ™¯éŸ³ä¹
    function toggleMusic() {
        if (gameState.musicOn) {
            elements.backgroundMusic.pause();
            elements.musicToggle.innerHTML = 'éŸ³ä¹å¼€/å…³ <span class="emoji">ğŸ”‡</span>';
        } else {
            elements.backgroundMusic.play();
            elements.musicToggle.innerHTML = 'éŸ³ä¹å¼€/å…³ <span class="emoji">ğŸµ</span>';
        }
        gameState.musicOn = !gameState.musicOn;
    }

    // ç”Ÿæˆæ¸¸æˆæ‹¼å›¾ç¢ç‰‡
    function generatePieces() {
        elements.pieces.innerHTML = '';
        gameState.pieces = [];
        
        // æŒ‰ç…§ç‰¹å®šè§„æ ¼ç”Ÿæˆæ‹¼å›¾
        const pieces = generateSpecificPieces();
        
        // è°ƒè¯•è¾“å‡º
        console.log(`ç”Ÿæˆäº† ${pieces.length} ä¸ªæ‹¼å›¾ï¼Œæ€»å…±è¦†ç›– ${pieces.reduce((sum, p) => sum + p.length, 0)} ä¸ªæ ¼å­`);
        
        gameState.totalPieces = pieces.length;
        
        // å°†æ‹¼å›¾æ·»åŠ åˆ°DOM
        pieces.forEach((piece, index) => {
            const color = colors[index % colors.length];
            const pieceElement = createPieceElement(piece, color, index);
            elements.pieces.appendChild(pieceElement);
            gameState.pieces.push({
                id: index,
                element: pieceElement,
                cells: piece,
                color: color,
                inGrid: false, // æ ‡è®°æ‹¼å›¾æ˜¯å¦åœ¨ç½‘æ ¼ä¸­
                position: null // åœ¨ç½‘æ ¼ä¸­çš„ä½ç½®
            });
        });
    }

    // æŒ‰ç…§ç‰¹å®šè§„æ ¼ç”Ÿæˆæ‹¼å›¾
    function generateSpecificPieces() {
        // åˆ›å»ºä¸€ä¸ª10x10çš„ç½‘æ ¼ï¼Œè¡¨ç¤ºæ•°å­—1-100
        const grid = Array(10).fill().map((_, row) => {
            return Array(10).fill().map((_, col) => ({
                row,
                col,
                number: row * 10 + col + 1,
                assigned: false,
                pieceId: -1 // ç”¨äºæ ‡è®°å±äºå“ªä¸ªæ‹¼å›¾
            }));
        });
        
        // è¦ç”Ÿæˆçš„æ‹¼å›¾è§„æ ¼: [å¤§å°, æ•°é‡]
        const pieceSpecs = [
            { size: 12, count: 3 },  // 12ä¸ªæ•°å­—çš„æ–¹å— x 3
            { size: 10, count: 5 },  // 10ä¸ªæ•°å­—çš„æ–¹å— x 5
            { size: 7, count: 2 }    // 7ä¸ªæ•°å­—çš„æ–¹å— x 2
        ];
        
        // éªŒè¯æ€»æ ¼å­æ•°æ˜¯å¦ä¸º100
        const totalCells = pieceSpecs.reduce((sum, spec) => sum + spec.size * spec.count, 0);
        if (totalCells !== 100) {
            console.warn(`æ‹¼å›¾è§„æ ¼æ€»æ ¼å­æ•°(${totalCells})ä¸ç­‰äº100ï¼Œå¯èƒ½æ— æ³•å¡«æ»¡ç™¾æ•°è¡¨`);
        }
        
        // åˆ›å»ºç¡®ä¿èƒ½å¡«æ»¡æ ¼å­çš„æ‹¼å›¾ç”Ÿæˆæ–¹æ¡ˆ
        let allPieces = generatePiecesToFillGrid(grid, pieceSpecs);
        
        // å¦‚æœæ— æ³•æŒ‰è§„æ ¼ç”Ÿæˆï¼Œå›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•å¹¶å°è¯•è¡¥é½
        if (!allPieces || allPieces.length === 0) {
            console.warn("ä½¿ç”¨å¡«å……ç®—æ³•ç”Ÿæˆæ‹¼å›¾å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•å¹¶å°è¯•è¡¥é½");
            allPieces = generatePiecesTraditionalWay(grid, pieceSpecs);
        }
        
        // æœ€åå¼ºåˆ¶ç¡®ä¿æ‹¼å›¾å—æ•°é‡ä¸º10ä¸ª
        allPieces = enforceExactlyTenPieces(allPieces, grid);
        
        return allPieces;
    }

    // å¼ºåˆ¶ç¡®ä¿æ‹¼å›¾å—æ•°é‡ä¸º10ä¸ª
    function enforceExactlyTenPieces(pieces, grid) {
        // å¦‚æœå·²ç»æ˜¯10ä¸ªï¼Œç›´æ¥è¿”å›
        if (pieces.length === 10) {
            return pieces;
        }
        
        console.log(`è°ƒæ•´æ‹¼å›¾å—æ•°é‡ï¼Œå½“å‰ä¸º${pieces.length}ï¼Œç›®æ ‡ä¸º10`);
        
        // å¦‚æœå°‘äº10ä¸ªæ‹¼å›¾ï¼Œéœ€è¦æ‹†åˆ†ä¸€äº›å¤§æ‹¼å›¾
        if (pieces.length < 10) {
            // å…ˆæŒ‰ç…§æ‹¼å›¾å¤§å°æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰
            pieces.sort((a, b) => b.length - a.length);
            
            while (pieces.length < 10) {
                // æ‰¾åˆ°æœ€å¤§çš„æ‹¼å›¾
                const largestPiece = pieces[0];
                
                // å¦‚æœæœ€å¤§æ‹¼å›¾çš„å¤§å°å°äº2ï¼Œæ— æ³•å†æ‹†åˆ†ï¼Œé€€å‡ºå¾ªç¯
                if (largestPiece.length < 2) {
                    console.warn("æ— æ³•æ‹†åˆ†å‡º10ä¸ªæ‹¼å›¾ï¼Œæ‹¼å›¾å·²ç»å¾ˆå°äº†");
                    break;
                }
                
                // è®¡ç®—è¦æ‹†åˆ†çš„å•å…ƒæ ¼æ•°é‡ï¼šå°½é‡ä½¿æ‹†åˆ†åçš„ä¸¤ä¸ªéƒ¨åˆ†å¤§å°ç›¸å½“
                const splitSize = Math.ceil(largestPiece.length / 2);
                
                // ä»æœ€å¤§æ‹¼å›¾ä¸­æ‹†åˆ†å‡ºä¸€éƒ¨åˆ†å•å…ƒæ ¼
                const newPiece = largestPiece.splice(splitSize);
                
                // å¦‚æœæ‹†åˆ†å‡ºçš„æ–°æ‹¼å›¾ä¸ä¸ºç©ºï¼Œæ·»åŠ åˆ°æ‹¼å›¾åˆ—è¡¨
                if (newPiece.length > 0) {
                    pieces.push(newPiece);
                }
                
                // é‡æ–°æ’åº
                pieces.sort((a, b) => b.length - a.length);
            }
        }
        
        // å¦‚æœè¶…è¿‡10ä¸ªæ‹¼å›¾ï¼Œéœ€è¦åˆå¹¶ä¸€äº›å°æ‹¼å›¾
        while (pieces.length > 10) {
            // æŒ‰ç…§æ‹¼å›¾å¤§å°æ’åºï¼ˆä»å°åˆ°å¤§ï¼‰
            pieces.sort((a, b) => a.length - b.length);
            
            // åˆå¹¶æœ€å°çš„ä¸¤ä¸ªæ‹¼å›¾
            const smallest1 = pieces.shift();
            const smallest2 = pieces.shift();
            
            // å°†å®ƒä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ‹¼å›¾
            const mergedPiece = [...smallest1, ...smallest2];
            pieces.push(mergedPiece);
        }
        
        // ç¡®ä¿æ‹¼å›¾å—ä¿¡æ¯å®Œæ•´
        return pieces.map(piece => {
            return piece.map(cell => {
                // ç¡®ä¿æ¯ä¸ªå•å…ƒæ ¼éƒ½æœ‰å®Œæ•´çš„ä¿¡æ¯
                if (typeof cell.number === 'undefined') {
                    // å¦‚æœç¼ºå°‘numberå±æ€§ï¼Œæ ¹æ®rowå’Œcolè®¡ç®—
                    return {
                        row: cell.row,
                        col: cell.col,
                        number: cell.row * 10 + cell.col + 1
                    };
                }
                return cell;
            });
        });
    }

    // ä½¿ç”¨æ–°ç®—æ³•ç”Ÿæˆèƒ½å¤Ÿå¡«æ»¡ç½‘æ ¼çš„æ‹¼å›¾å—
    function generatePiecesToFillGrid(grid, pieceSpecs) {
        // åˆ›å»ºä¸€ä¸ªå¸¦æœ‰æ‹¼å›¾IDçš„ç½‘æ ¼å‰¯æœ¬
        const filledGrid = Array(10).fill().map((_, row) => {
            return Array(10).fill().map((_, col) => ({
                row, 
                col,
                pieceId: -1,
                assigned: false
            }));
        });
        
        // åˆ›å»º10ä¸ªæ‹¼å›¾å—ï¼Œæ¯ä¸ªæ‹¼å›¾å—ä¿å­˜å…¶åŒ…å«çš„å•å…ƒæ ¼
        const pieces = [];
        let currentPieceId = 0;
        
        // æŒ‰ç…§è§„æ ¼é¡ºåºç”Ÿæˆæ‹¼å›¾
        for (const spec of pieceSpecs) {
            const { size, count } = spec;
            
            for (let i = 0; i < count; i++) {
                if (currentPieceId >= 10) break; // æœ€å¤š10ä¸ªæ‹¼å›¾å—
                
                // æ‰¾ä¸€ä¸ªæœªåˆ†é…çš„èµ·å§‹ç‚¹
                let startCell = findUnassignedCell(filledGrid);
                if (!startCell) {
                    console.warn("æ— æ³•æ‰¾åˆ°æœªåˆ†é…çš„èµ·å§‹å•å…ƒæ ¼");
                    break;
                }
                
                // ä»è¿™ä¸ªèµ·å§‹ç‚¹ç”Ÿæˆä¸€ä¸ªæŒ‡å®šå¤§å°çš„è¿é€šæ‹¼å›¾
                const piece = growPieceFromSeed(filledGrid, startCell, size, currentPieceId);
                
                if (piece && piece.length === size) {
                    pieces.push(piece);
                    currentPieceId++;
                } else {
                    console.warn(`æ— æ³•ç”Ÿæˆå¤§å°ä¸º ${size} çš„æ‹¼å›¾`);
                    // å¦‚æœæ— æ³•ç”Ÿæˆï¼Œåˆ™æ¸…é™¤éƒ¨åˆ†åˆ†é…çš„å•å…ƒæ ¼
                    if (piece) {
                        piece.forEach(cell => {
                            filledGrid[cell.row][cell.col].pieceId = -1;
                            filledGrid[cell.row][cell.col].assigned = false;
                        });
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å•å…ƒæ ¼éƒ½å·²åˆ†é…
        let allAssigned = true;
        const unassignedCells = [];
        
        for (let row = 0; row < 10; row++) {
            for (let col = 0; col < 10; col++) {
                if (filledGrid[row][col].pieceId === -1) {
                    allAssigned = false;
                    unassignedCells.push({row, col});
                }
            }
        }
        
        // å¦‚æœè¿˜æœ‰æœªåˆ†é…çš„å•å…ƒæ ¼ï¼Œå°è¯•å°†å®ƒä»¬åˆ†é…åˆ°å·²æœ‰çš„æ‹¼å›¾ä¸­
        if (!allAssigned && pieces.length > 0) {
            console.warn(`æœ‰ ${unassignedCells.length} ä¸ªå•å…ƒæ ¼æœªåˆ†é…ï¼Œå°è¯•æ·»åŠ åˆ°ç°æœ‰æ‹¼å›¾`);
            
            // æŒ‰ç…§æ‹¼å›¾IDåˆ†ç»„
            const pieceGroups = {};
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    const pieceId = filledGrid[row][col].pieceId;
                    if (pieceId !== -1) {
                        if (!pieceGroups[pieceId]) {
                            pieceGroups[pieceId] = [];
                        }
                        pieceGroups[pieceId].push({row, col});
                    }
                }
            }
            
            // å¯¹äºæ¯ä¸ªæœªåˆ†é…çš„å•å…ƒæ ¼ï¼Œæ‰¾ä¸€ä¸ªç›¸é‚»çš„æ‹¼å›¾æ·»åŠ 
            for (const cell of unassignedCells) {
                let added = false;
                
                // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„ç›¸é‚»å•å…ƒæ ¼
                const directions = [{r:-1,c:0}, {r:0,c:1}, {r:1,c:0}, {r:0,c:-1}];
                
                for (const dir of directions) {
                    const adjRow = cell.row + dir.r;
                    const adjCol = cell.col + dir.c;
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨ç½‘æ ¼èŒƒå›´å†…
                    if (adjRow >= 0 && adjRow < 10 && adjCol >= 0 && adjCol < 10) {
                        const adjPieceId = filledGrid[adjRow][adjCol].pieceId;
                        
                        // å¦‚æœç›¸é‚»å•å…ƒæ ¼å·²åˆ†é…åˆ°æŸä¸ªæ‹¼å›¾ï¼Œåˆ™å°†å½“å‰å•å…ƒæ ¼ä¹Ÿåˆ†é…ç»™å®ƒ
                        if (adjPieceId !== -1) {
                            filledGrid[cell.row][cell.col].pieceId = adjPieceId;
                            filledGrid[cell.row][cell.col].assigned = true;
                            
                            // æ›´æ–°piecesæ•°ç»„
                            const originalCells = grid[cell.row][cell.col];
                            pieces[adjPieceId].push({
                                row: cell.row,
                                col: cell.col,
                                number: cell.row * 10 + cell.col + 1
                            });
                            
                            added = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰ç›¸é‚»çš„æ‹¼å›¾ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªæ‹¼å›¾æ·»åŠ 
                if (!added && pieces.length > 0) {
                    const randomPieceId = Math.floor(Math.random() * pieces.length);
                    filledGrid[cell.row][cell.col].pieceId = randomPieceId;
                    filledGrid[cell.row][cell.col].assigned = true;
                    
                    // æ›´æ–°piecesæ•°ç»„
                    pieces[randomPieceId].push({
                        row: cell.row,
                        col: cell.col,
                        number: cell.row * 10 + cell.col + 1
                    });
                }
            }
        }
        
        // å°†æ‹¼å›¾IDè½¬æ¢ä¸ºå®é™…çš„æ‹¼å›¾æ•°æ®
        const result = [];
        for (let i = 0; i < pieces.length; i++) {
            // ç¡®ä¿æ¯ä¸ªæ‹¼å›¾åŒ…å«åŸå§‹æ•°æ®
            const pieceCells = pieces[i].map(cell => ({
                row: cell.row,
                col: cell.col,
                number: cell.row * 10 + cell.col + 1
            }));
            
            result.push(pieceCells);
        }
        
        // ç¡®ä¿æ‹¼å›¾æ•°é‡ä¸è¶…è¿‡10ä¸ª
        return result.slice(0, 10);
    }

    // æŸ¥æ‰¾ç½‘æ ¼ä¸­æœªåˆ†é…çš„å•å…ƒæ ¼
    function findUnassignedCell(grid) {
        for (let row = 0; row < 10; row++) {
            for (let col = 0; col < 10; col++) {
                if (!grid[row][col].assigned) {
                    return {row, col};
                }
            }
        }
        return null;
    }

    // ä»ç§å­å•å…ƒæ ¼ç”Ÿé•¿æŒ‡å®šå¤§å°çš„æ‹¼å›¾
    function growPieceFromSeed(grid, seed, targetSize, pieceId) {
        const cells = [];
        const queue = [seed];
        
        // æ ‡è®°ç§å­å•å…ƒæ ¼ä¸ºå·²åˆ†é…
        grid[seed.row][seed.col].assigned = true;
        grid[seed.row][seed.col].pieceId = pieceId;
        cells.push({row: seed.row, col: seed.col});
        
        // å®šä¹‰å››ä¸ªæ–¹å‘ï¼šä¸Šã€å³ã€ä¸‹ã€å·¦
        const directions = [
            {r: -1, c: 0},  // ä¸Š
            {r: 0, c: 1},   // å³
            {r: 1, c: 0},   // ä¸‹
            {r: 0, c: -1}   // å·¦
        ];
        
        // éšæœºæ’åºæ–¹å‘ï¼Œå¢åŠ æ‹¼å›¾å½¢çŠ¶çš„éšæœºæ€§
        shuffleArray(directions);
        
        // ä»ç§å­å¼€å§‹ï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢æ‰©å±•æ‹¼å›¾
        while (cells.length < targetSize && queue.length > 0) {
            const current = queue.shift();
            
            // å†æ¬¡éšæœºæ’åºæ–¹å‘
            shuffleArray(directions);
            
            // å°è¯•å››ä¸ªæ–¹å‘æ‰©å±•
            for (const dir of directions) {
                if (cells.length >= targetSize) break;
                
                const newRow = current.row + dir.r;
                const newCol = current.col + dir.c;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨ç½‘æ ¼èŒƒå›´å†…
                if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
                    // æ£€æŸ¥æ˜¯å¦å·²åˆ†é…
                    if (!grid[newRow][newCol].assigned) {
                        // æ ‡è®°ä¸ºå·²åˆ†é…
                        grid[newRow][newCol].assigned = true;
                        grid[newRow][newCol].pieceId = pieceId;
                        
                        // æ·»åŠ åˆ°æ‹¼å›¾å’Œé˜Ÿåˆ—
                        cells.push({row: newRow, col: newCol});
                        queue.push({row: newRow, col: newCol});
                    }
                }
            }
        }
        
        return cells;
    }

    // æ•°ç»„éšæœºæ‰“ä¹±å‡½æ•°
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    // ä¼ ç»Ÿæ–¹å¼ç”Ÿæˆæ‹¼å›¾ï¼Œå¹¶å°è¯•è¡¥é½æœªåˆ†é…æ ¼å­
    function generatePiecesTraditionalWay(grid, pieceSpecs) {
        const allPieces = [];
        
        // æŒ‰è§„æ ¼ç”Ÿæˆæ‹¼å›¾
        for (const spec of pieceSpecs) {
            const { size, count } = spec;
            
            for (let i = 0; i < count; i++) {
                // å°è¯•å¤šæ¬¡ç”Ÿæˆå½“å‰è§„æ ¼çš„æ‹¼å›¾
                let piece = null;
                for (let attempt = 0; attempt < 200; attempt++) {
                    piece = generateConnectedPiece(grid, size);
                    if (piece) break;
                }
                
                if (piece) {
                    allPieces.push(piece);
                    // æ ‡è®°å·²åˆ†é…çš„æ ¼å­
                    piece.forEach(cell => {
                        grid[cell.row][cell.col].assigned = true;
                    });
                } else {
                    console.warn(`æ— æ³•ç”Ÿæˆå¤§å°ä¸º ${size} çš„æ‹¼å›¾ #${i+1}ï¼Œå°è¯•ç”Ÿæˆè¾ƒå°æ‹¼å›¾`);
                    
                    // å¦‚æœæ— æ³•ç”ŸæˆæŒ‡å®šå¤§å°çš„æ‹¼å›¾ï¼Œå°è¯•ç”Ÿæˆè¾ƒå°çš„æ‹¼å›¾
                    const smallerSize = Math.max(4, size - 2);
                    for (let attempt = 0; attempt < 200; attempt++) {
                        piece = generateConnectedPiece(grid, smallerSize);
                        if (piece) break;
                    }
                    
                    if (piece) {
                        allPieces.push(piece);
                        piece.forEach(cell => {
                            grid[cell.row][cell.col].assigned = true;
                        });
                    } else {
                        console.warn(`æ— æ³•ç”Ÿæˆå¤§å°ä¸º ${smallerSize} çš„æ›¿ä»£æ‹¼å›¾`);
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ‹¼å›¾å—æ•°é‡ï¼Œç¡®ä¿æ€»æ•°ä¸º10ä¸ª
        if (allPieces.length < 10) {
            console.warn(`ç”Ÿæˆçš„æ‹¼å›¾å—ä¸è¶³10ä¸ªï¼Œå½“å‰ä¸º${allPieces.length}ä¸ªï¼Œå°è¯•ç”Ÿæˆé¢å¤–æ‹¼å›¾`);
            
            // è®¡ç®—å‰©ä½™æœªåˆ†é…çš„æ ¼å­
            const unassignedCells = [];
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 10; col++) {
                    if (!grid[row][col].assigned) {
                        unassignedCells.push(grid[row][col]);
                    }
                }
            }
            
            // å¦‚æœè¿˜æœ‰æœªåˆ†é…çš„æ ¼å­ï¼Œå¹¶ä¸”æ‹¼å›¾æ•°é‡ä¸è¶³10ä¸ªï¼Œç”Ÿæˆé¢å¤–æ‹¼å›¾
            const neededPieces = 10 - allPieces.length;
            if (unassignedCells.length > 0 && neededPieces > 0) {
                // è®¡ç®—æ¯ä¸ªé¢å¤–æ‹¼å›¾çš„å¹³å‡å¤§å°
                const avgSize = Math.floor(unassignedCells.length / neededPieces);
                
                for (let i = 0; i < neededPieces && unassignedCells.length > 0; i++) {
                    // ç¡®å®šå½“å‰æ‹¼å›¾çš„å¤§å°ï¼ˆæœ€åä¸€ä¸ªå¯èƒ½éœ€è¦æ”¶é›†æ‰€æœ‰å‰©ä½™çš„æ ¼å­ï¼‰
                    const pieceSize = (i === neededPieces - 1) 
                        ? unassignedCells.length 
                        : Math.min(avgSize, unassignedCells.length);
                    
                    if (pieceSize < 1) continue;
                    
                    // å°è¯•ç”Ÿæˆè¿æ¥çš„æ‹¼å›¾
                    const startCell = unassignedCells[0];
                    const connectedCells = findConnectedCells(grid, startCell, pieceSize);
                    
                    if (connectedCells.length > 0) {
                        allPieces.push(connectedCells);
                        // æ ‡è®°ä¸ºå·²åˆ†é…ï¼Œå¹¶ä»æœªåˆ†é…åˆ—è¡¨ä¸­ç§»é™¤
                        connectedCells.forEach(cell => {
                            grid[cell.row][cell.col].assigned = true;
                            const index = unassignedCells.findIndex(c => 
                                c.row === cell.row && c.col === cell.col);
                            if (index !== -1) {
                                unassignedCells.splice(index, 1);
                            }
                        });
                    }
                }
            }
            
            // å¦‚æœè¿˜æœ‰æœªåˆ†é…çš„æ ¼å­ï¼Œå°†å®ƒä»¬åˆ†é…åˆ°ç°æœ‰çš„æ‹¼å›¾ä¸­
            if (unassignedCells.length > 0 && allPieces.length > 0) {
                for (const cell of unassignedCells) {
                    // æ‰¾ä¸€ä¸ªç›¸é‚»çš„æ‹¼å›¾æ·»åŠ 
                    let added = false;
                    
                    // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„ç›¸é‚»å•å…ƒæ ¼
                    const directions = [{r:-1,c:0}, {r:0,c:1}, {r:1,c:0}, {r:0,c:-1}];
                    
                    // æŸ¥æ‰¾å‘¨å›´æœ‰æ²¡æœ‰å·²åˆ†é…çš„æ ¼å­ï¼Œå¦‚æœæœ‰ï¼Œåˆ™åŠ å…¥åŒä¸€ä¸ªæ‹¼å›¾
                    for (let i = 0; i < allPieces.length && !added; i++) {
                        const piece = allPieces[i];
                        for (const pieceCell of piece) {
                            for (const dir of directions) {
                                if (pieceCell.row + dir.r === cell.row && pieceCell.col + dir.c === cell.col) {
                                    piece.push(cell);
                                    grid[cell.row][cell.col].assigned = true;
                                    added = true;
                                    break;
                                }
                            }
                            if (added) break;
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰ç›¸é‚»çš„æ‹¼å›¾ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªæ‹¼å›¾æ·»åŠ 
                    if (!added && allPieces.length > 0) {
                        const randomPieceIndex = Math.floor(Math.random() * allPieces.length);
                        allPieces[randomPieceIndex].push(cell);
                        grid[cell.row][cell.col].assigned = true;
                    }
                }
            }
        } else if (allPieces.length > 10) {
            // å¦‚æœç”Ÿæˆçš„æ‹¼å›¾å—è¶…è¿‡10ä¸ªï¼Œåˆ™åªä¿ç•™å‰10ä¸ª
            console.warn(`ç”Ÿæˆçš„æ‹¼å›¾å—è¶…è¿‡10ä¸ªï¼Œå½“å‰ä¸º${allPieces.length}ä¸ªï¼Œå°†åªä¿ç•™å‰10ä¸ª`);
            allPieces.splice(10);
        }
        
        // ç¡®ä¿è¿”å›çš„æ‹¼å›¾å—æ•°é‡ä¸è¶…è¿‡10ä¸ª
        return allPieces.slice(0, 10);
    }

    // åˆ›å»ºæ‹¼å›¾DOMå…ƒç´ 
    function createPieceElement(cells, color, id) {
        // è®¡ç®—æ‹¼å›¾çš„è¾¹ç•Œ
        const rows = cells.map(cell => cell.row);
        const cols = cells.map(cell => cell.col);
        const minRow = Math.min(...rows);
        const maxRow = Math.max(...rows);
        const minCol = Math.min(...cols);
        const maxCol = Math.max(...cols);
        
        // è®¡ç®—å°ºå¯¸
        const numRows = maxRow - minRow + 1;
        const numCols = maxCol - minCol + 1;
        
        // åˆ›å»ºæ‹¼å›¾å®¹å™¨
        const pieceElement = document.createElement('div');
        pieceElement.className = 'piece';
        pieceElement.style.gridTemplateRows = `repeat(${numRows}, 40px)`;
        pieceElement.style.gridTemplateColumns = `repeat(${numCols}, 40px)`;
        pieceElement.draggable = true; // ç¡®ä¿å…ƒç´ å¯æ‹–æ‹½
        
        // å­˜å‚¨å…³é”®ä¿¡æ¯ï¼Œç”¨äºæ”¾ç½®
        pieceElement.dataset.pieceId = id;
        pieceElement.dataset.minRow = minRow;
        pieceElement.dataset.minCol = minCol;
        
        // è®¾ç½®æ‹¼å›¾çš„æ•°æ®å±æ€§
        pieceElement.dataset.cells = JSON.stringify(cells);
        
        // ä¸ºæ‹¼å›¾æ·»åŠ æ‹–åŠ¨äº‹ä»¶
        pieceElement.addEventListener('dragstart', handleDragStart);
        pieceElement.addEventListener('dragend', handleDragEnd);
        
        // ç¡®ä¿é¼ æ ‡æ ·å¼æ­£ç¡®
        pieceElement.style.cursor = 'grab';
        
        // åˆ›å»ºæ‹¼å›¾å•å…ƒæ ¼ä½ç½®æ˜ å°„
        const cellMap = {};
        cells.forEach(cell => {
            const key = `${cell.row - minRow},${cell.col - minCol}`;
            cellMap[key] = cell;
        });
        
        // å¡«å……æ‹¼å›¾ç½‘æ ¼
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                const key = `${i},${j}`;
                const pieceCell = document.createElement('div');
                pieceCell.className = 'piece-cell';
                
                if (cellMap[key]) {
                    pieceCell.style.backgroundColor = color;
                    pieceCell.textContent = cellMap[key].number;
                    pieceCell.dataset.number = cellMap[key].number;
                    pieceCell.dataset.row = cellMap[key].row;
                    pieceCell.dataset.col = cellMap[key].col;
                } else {
                    pieceCell.style.visibility = 'hidden';
                }
                
                pieceElement.appendChild(pieceCell);
            }
        }
        
        return pieceElement;
    }

    // å¤„ç†æ‹–åŠ¨å¤„ç†å‡½æ•°
    function handleDragStart(e) {
        // ç¡®ä¿é¼ æ ‡å·¦é”®äº‹ä»¶
        if (e.button !== 0) return;
        
        // ä¿å­˜è¢«æ‹–åŠ¨å…ƒç´ çš„ä¿¡æ¯
        const piece = e.currentTarget;
        const pieceId = parseInt(piece.dataset.pieceId);
        const pieceObj = gameState.pieces[pieceId];
        
        // ä¿å­˜å½“å‰æ‹–åŠ¨çš„æ‹¼å›¾ï¼Œç”¨äºé¢„è§ˆ
        gameState.currentDraggingPiece = pieceObj;
        
        // åˆ¤æ–­æ‹¼å›¾æ˜¯å¦åœ¨ç½‘æ ¼ä¸­ï¼Œå¦‚æœæ˜¯ï¼Œä»åŸä½ç½®ç§»é™¤
        if (pieceObj.inGrid) {
            // ä¸´æ—¶ä¿å­˜ä½ç½®ä¿¡æ¯ï¼Œç”¨äºæ”¾ç½®å›ç›¸åŒä½ç½®æ—¶é¿å…é‡å¤ç»˜åˆ¶
            pieceObj._lastPosition = {
                row: pieceObj.position.row,
                col: pieceObj.position.col
            };
            
            // ä»åŸä½ç½®ç§»é™¤æ ¼å­æ•°æ®ï¼Œä½†ä¸ç§»é™¤DOMå…ƒç´ 
            removePieceFromGridData(pieceId);
        }
        
        // è®¾ç½®ä¼ è¾“æ•°æ®
        e.dataTransfer.setData('text/plain', JSON.stringify({
            pieceId: pieceId,
            minRow: parseInt(piece.dataset.minRow),
            minCol: parseInt(piece.dataset.minCol),
            fromGrid: pieceObj.inGrid, // æ˜¯å¦ä»ç½‘æ ¼ä¸­æ‹–æ‹½
        }));
        
        // è®¾ç½®æ‹–æ‹½æ•ˆæœ
        e.dataTransfer.effectAllowed = 'move';
        
        // æ ·å¼è°ƒæ•´
        piece.classList.add('dragging');
        piece.style.zIndex = '1000';
        
        // é˜»æ­¢äº‹ä»¶å†’æ³¡
        e.stopPropagation();
    }

    function handleDragEnd(e) {
        const piece = e.currentTarget;
        piece.classList.remove('dragging');
        piece.style.zIndex = '';
        
        // æ¸…é™¤é¢„è§ˆ
        clearPiecePreview();
        gameState.currentDraggingPiece = null;
    }

    // å¤„ç†æ‹–åŠ¨ç»è¿‡äº‹ä»¶
    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        if (!gameState.isGameStarted || !gameState.currentDraggingPiece) return;
        
        // è·å–ç½‘æ ¼å…ƒç´ çš„ä½ç½®
        const gridRect = elements.numberGrid.getBoundingClientRect();
        
        // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨ç½‘æ ¼å†…
        const isMouseInGrid = 
            e.clientX >= gridRect.left && 
            e.clientX < gridRect.right && 
            e.clientY >= gridRect.top && 
            e.clientY < gridRect.bottom;
            
        if (isMouseInGrid) {
            // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºç½‘æ ¼çš„ä½ç½®
            const relX = e.clientX - gridRect.left;
            const relY = e.clientY - gridRect.top;
            
            // è®¡ç®—å¯¹åº”çš„ç½‘æ ¼è¡Œåˆ—
            const cellSize = 40;
            const col = Math.floor(relX / cellSize);
            const row = Math.floor(relY / cellSize);
            
            // ç¡®ä¿targetRowå’ŒtargetColåœ¨åˆç†èŒƒå›´å†…ï¼ˆ0-9ï¼‰
            const targetRow = Math.max(0, Math.min(9, row));
            const targetCol = Math.max(0, Math.min(9, col));
            
            // è·å–å½“å‰æ‹–åŠ¨çš„æ‹¼å›¾
            const piece = gameState.currentDraggingPiece;
            
            // æ˜¾ç¤ºæ‹¼å›¾é¢„è§ˆ
            showPiecePreview(piece, targetRow, targetCol);
        } else {
            // ä¸åœ¨ç½‘æ ¼å†…ï¼Œæ¸…é™¤é¢„è§ˆ
            clearPiecePreview();
        }
    }

    function handleDragEnter(e) {
        e.preventDefault();
        e.currentTarget.classList.add('highlight');
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('highlight');
    }

    // æ˜¾ç¤ºæ‹¼å›¾é¢„è§ˆ
    function showPiecePreview(piece, targetRow, targetCol) {
        // æ¸…é™¤ä¹‹å‰çš„é¢„è§ˆ
        clearPiecePreview();
        
        // å¦‚æœæ²¡æœ‰æ‹¼å›¾æˆ–æ¸¸æˆæœªå¼€å§‹ï¼Œä¸æ˜¾ç¤ºé¢„è§ˆ
        if (!piece || !gameState.isGameStarted) return;
        
        // è·å–æ‹¼å›¾çš„æœ€å°è¡Œåˆ—å€¼
        const minRow = Math.min(...piece.cells.map(cell => cell.row));
        const minCol = Math.min(...piece.cells.map(cell => cell.col));
        
        // åˆ›å»ºæˆ–ä½¿ç”¨é¢„è§ˆå…ƒç´ 
        if (!gameState.previewElement) {
            gameState.previewElement = document.createElement('div');
            gameState.previewElement.className = 'piece-preview';
            elements.numberGrid.appendChild(gameState.previewElement);
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”¾ç½®
        let canPlace = true;
        const affectedCells = [];
        
        for (const cell of piece.cells) {
            // è®¡ç®—ç›¸å¯¹äºæ‹¼å›¾å·¦ä¸Šè§’çš„åç§»
            const relativeRow = cell.row - minRow;
            const relativeCol = cell.col - minCol;
            
            // è®¡ç®—åœ¨ç½‘æ ¼ä¸­çš„å®é™…ä½ç½®
            const gridRow = targetRow + relativeRow;
            const gridCol = targetCol + relativeCol;
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨ç½‘æ ¼å†…
            if (gridRow < 0 || gridRow >= 10 || gridCol < 0 || gridCol >= 10) {
                canPlace = false;
                break;
            }
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨ï¼ˆä¸æ˜¯è¢«è‡ªå·±å ç”¨ï¼‰
            if (gameState.grid[gridRow][gridCol].filled && 
                gameState.grid[gridRow][gridCol].pieceId !== piece.id) {
                canPlace = false;
                break;
            }
            
            affectedCells.push({
                cell: cell,
                gridRow: gridRow,
                gridCol: gridCol,
                isCorrect: cell.number === gameState.grid[gridRow][gridCol].number
            });
        }
        
        // è®¡ç®—é¢„è§ˆå…ƒç´ çš„å°ºå¯¸å’Œä½ç½®
        const cellSize = 40; // å•å…ƒæ ¼å¤§å°
        
        // è®¡ç®—é¢„è§ˆå°ºå¯¸ï¼ˆå§‹ç»ˆä½¿ç”¨æ‹¼å›¾çš„å®é™…å¤§å°ï¼‰
        const rowsCount = Math.max(...piece.cells.map(c => c.row - minRow)) + 1;
        const colsCount = Math.max(...piece.cells.map(c => c.col - minCol)) + 1;
        
        // è®¾ç½®é¢„è§ˆå…ƒç´ çš„æ ·å¼ï¼Œç¡®ä¿ä¸ç½‘æ ¼å®Œå…¨å¯¹é½
        gameState.previewElement.style.position = 'absolute';
        gameState.previewElement.style.left = `${targetCol * cellSize}px`;
        gameState.previewElement.style.top = `${targetRow * cellSize}px`;
        gameState.previewElement.style.width = `${colsCount * cellSize}px`;
        gameState.previewElement.style.height = `${rowsCount * cellSize}px`;
        gameState.previewElement.style.display = 'grid';
        gameState.previewElement.style.gridTemplateRows = `repeat(${rowsCount}, ${cellSize}px)`;
        gameState.previewElement.style.gridTemplateColumns = `repeat(${colsCount}, ${cellSize}px)`;
        gameState.previewElement.style.pointerEvents = 'none'; // ç¡®ä¿ä¸ä¼šå¹²æ‰°æ‹–æ‹½äº‹ä»¶
        gameState.previewElement.style.zIndex = '10'; // ç¡®ä¿é¢„è§ˆæ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚
        
        // è®¾ç½®è¾¹æ¡†æ ·å¼ï¼Œåæ˜ æ˜¯å¦å¯æ”¾ç½®
        if (canPlace) {
            gameState.previewElement.style.border = '2px solid rgba(50, 205, 50, 0.8)';
            gameState.previewElement.style.boxShadow = '0 0 15px rgba(50, 205, 50, 0.6)';
        } else {
            gameState.previewElement.style.border = '2px solid rgba(255, 69, 0, 0.8)';
            gameState.previewElement.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.6)';
        }
        
        // åˆ›å»ºé¢„è§ˆå•å…ƒæ ¼
        gameState.previewElement.innerHTML = '';
        
        // åˆ›å»ºé¢„è§ˆç½‘æ ¼
        const previewGrid = Array(rowsCount).fill().map(() => Array(colsCount).fill(null));
        
        // å¡«å……é¢„è§ˆç½‘æ ¼
        for (const cell of piece.cells) {
            const rowIndex = cell.row - minRow;
            const colIndex = cell.col - minCol;
            
            // æ‰¾åˆ°å¯¹åº”çš„å—å½±å“å•å…ƒæ ¼
            const affectedCell = affectedCells.find(a => 
                a.cell.row === cell.row && a.cell.col === cell.col);
                
            if (affectedCell) {
                previewGrid[rowIndex][colIndex] = affectedCell;
            }
        }
        
        // åŸºäºé¢„è§ˆç½‘æ ¼åˆ›å»ºå•å…ƒæ ¼
        for (let r = 0; r < rowsCount; r++) {
            for (let c = 0; c < colsCount; c++) {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'preview-cell';
                cellDiv.style.width = `${cellSize - 2}px`;
                cellDiv.style.height = `${cellSize - 2}px`;
                cellDiv.style.margin = '1px';
                cellDiv.style.display = 'flex';
                cellDiv.style.justifyContent = 'center';
                cellDiv.style.alignItems = 'center';
                cellDiv.style.fontSize = '16px';
                cellDiv.style.fontWeight = 'bold';
                
                const affectedCell = previewGrid[r][c];
                if (affectedCell) {
                    // æ ¹æ®æ”¾ç½®çŠ¶æ€è®¾ç½®é€‚å½“çš„æ ·å¼ç±»å’Œé¢œè‰²
                    if (canPlace) {
                        if (affectedCell.isCorrect) {
                            cellDiv.classList.add('correct');
                            cellDiv.style.backgroundColor = 'rgba(50, 205, 50, 0.7)';
                            cellDiv.style.border = '2px solid rgba(0, 128, 0, 0.9)';
                        } else {
                            cellDiv.classList.add('incorrect');
                            cellDiv.style.backgroundColor = 'rgba(255, 165, 0, 0.7)';
                            cellDiv.style.border = '2px solid rgba(255, 140, 0, 0.9)';
                        }
                    } else {
                        cellDiv.style.backgroundColor = 'rgba(255, 69, 0, 0.7)';
                        cellDiv.style.border = '2px solid rgba(178, 34, 34, 0.9)';
                    }
                    
                    // æ˜¾ç¤ºæ•°å­—
                    cellDiv.textContent = affectedCell.cell.number;
                    
                    // ä¿å­˜åˆ°é¢„è§ˆå•å…ƒæ ¼æ•°ç»„
                    gameState.previewCells.push(cellDiv);
                } else {
                    cellDiv.style.visibility = 'hidden';
                }
                
                gameState.previewElement.appendChild(cellDiv);
            }
        }
    }

    // æ¸…é™¤æ‹¼å›¾é¢„è§ˆ
    function clearPiecePreview() {
        // æ¸…é™¤é¢„è§ˆå•å…ƒæ ¼
        gameState.previewCells = [];
        
        // éšè—é¢„è§ˆå…ƒç´ 
        if (gameState.previewElement) {
            gameState.previewElement.style.display = 'none';
            gameState.previewElement.innerHTML = '';
        }
    }

    // ä»ç½‘æ ¼ä¸­ç§»é™¤æ‹¼å›¾æ•°æ®ï¼Œä½†ä¿ç•™DOMå…ƒç´ 
    function removePieceFromGridData(pieceId) {
        const piece = gameState.pieces[pieceId];
        if (!piece.inGrid) return;
        
        const position = piece.position;
        
        // æ¸…é™¤ç½‘æ ¼ç›¸å…³å•å…ƒæ ¼çš„çŠ¶æ€ï¼Œå¹¶æ¸…é™¤æ˜¾ç¤º
        for (const cell of piece.cells) {
            const gridRow = cell.row - position.minRow + position.row;
            const gridCol = cell.col - position.minCol + position.col;
            
            if (gridRow >= 0 && gridRow < 10 && gridCol >= 0 && gridCol < 10) {
                const gridCell = gameState.grid[gridRow][gridCol];
                if (gridCell.pieceId === pieceId) {
                    gridCell.filled = false;
                    gridCell.pieceId = null;
                    // æ¸…é™¤å•å…ƒæ ¼æ˜¾ç¤ºï¼Œé¿å…é‡å¤æ˜¾ç¤º
                    gridCell.element.style.backgroundColor = '';
                    gridCell.element.textContent = '';
                    gridCell.element.style.outline = '';
                }
            }
        }
        
        // æ ‡è®°æ‹¼å›¾ä¸ºéç½‘æ ¼çŠ¶æ€ï¼Œä½†ä¸åˆ é™¤DOMå…ƒç´ 
        piece.inGrid = false;
        // ä¿ç•™positionä¿¡æ¯ï¼Œå¦‚æœæ‹–æ‹½å¤±è´¥å¯ä»¥ç”¨æ¥æ¢å¤
    }

    // å®Œå…¨ä»ç½‘æ ¼ä¸­ç§»é™¤æ‹¼å›¾ï¼ŒåŒ…æ‹¬DOMå…ƒç´ 
    function removePieceFromGrid(pieceId) {
        const piece = gameState.pieces[pieceId];
        if (!piece.inGrid) return;
        
        const position = piece.position;
        
        // æ¸…é™¤ç½‘æ ¼ç›¸å…³å•å…ƒæ ¼çš„çŠ¶æ€
        for (const cell of piece.cells) {
            const gridRow = cell.row - position.minRow + position.row;
            const gridCol = cell.col - position.minCol + position.col;
            
            if (gridRow >= 0 && gridRow < 10 && gridCol >= 0 && gridCol < 10) {
                const gridCell = gameState.grid[gridRow][gridCol];
                if (gridCell.pieceId === pieceId) {
                    gridCell.filled = false;
                    gridCell.pieceId = null;
                    gridCell.element.style.backgroundColor = '';
                    gridCell.element.textContent = '';
                    gridCell.element.style.outline = '';
                }
            }
        }
        
        // æ›´æ–°æ‹¼å›¾çŠ¶æ€
        piece.inGrid = false;
        piece.position = null;
        
        // æ£€æŸ¥æ˜¯å¦æ­£ç¡®æ”¾ç½®ï¼Œå¦‚æœæ˜¯ï¼Œå‡å°‘è®¡æ•°
        checkCorrectPlacement(piece, true);
        
        // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
        checkGameCompletion();
    }

    // æ”¾ç½®æ‹¼å›¾åˆ°ç½‘æ ¼
    function placePieceToGrid(pieceId, row, col) {
        const piece = gameState.pieces[pieceId];
        
        // å¦‚æœè¿™ä¸ªæ‹¼å›¾ä¹‹å‰å·²åœ¨ç½‘æ ¼ä¸­çš„å…¶ä»–ä½ç½®ï¼Œç¡®ä¿å®Œå…¨ç§»é™¤æ—§ä½ç½®çš„æ˜¾ç¤º
        if (piece.inGrid && piece.position && 
           (piece.position.row !== row || piece.position.col !== col)) {
            // å®Œå…¨ä»åŸä½ç½®ç§»é™¤ï¼ˆæ•°æ®å’Œæ˜¾ç¤ºï¼‰
            removePieceFromGridData(pieceId);
        }
        
        // æ£€æŸ¥æ˜¯å¦æ”¾å›åŸä½ç½®ï¼Œå¦‚æœæ˜¯åˆ™æ— éœ€æ“ä½œ
        if (piece._lastPosition && piece._lastPosition.row === row && piece._lastPosition.col === col) {
            // æ¢å¤æ‹¼å›¾åœ¨ç½‘æ ¼ä¸­çš„çŠ¶æ€
            restorePieceInGrid(pieceId, piece._lastPosition);
            piece._lastPosition = null;
            return true; // ç›´æ¥è¿”å›æˆåŠŸ
        }
        
        const minRow = Math.min(...piece.cells.map(cell => cell.row));
        const minCol = Math.min(...piece.cells.map(cell => cell.col));
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”¾ç½®
        let canPlace = true;
        const affectedCells = [];
        
        for (const cell of piece.cells) {
            const relativeRow = cell.row - minRow;
            const relativeCol = cell.col - minCol;
            
            const gridRow = row + relativeRow;
            const gridCol = col + relativeCol;
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨ç½‘æ ¼å†…
            if (gridRow < 0 || gridRow >= 10 || gridCol < 0 || gridCol >= 10) {
                canPlace = false;
                break;
            }
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨ï¼ˆä¸æ˜¯è¢«è‡ªå·±å ç”¨ï¼‰
            if (gameState.grid[gridRow][gridCol].filled && 
                gameState.grid[gridRow][gridCol].pieceId !== pieceId) {
                canPlace = false;
                break;
            }
            
            affectedCells.push({
                cell: cell,
                gridRow: gridRow,
                gridCol: gridCol
            });
        }
        
        if (canPlace) {
            // æ¸…é™¤é¢„è§ˆ
            clearPiecePreview();
            
            // æ”¾ç½®æ‹¼å›¾
            for (const {cell, gridRow, gridCol} of affectedCells) {
                const gridCell = gameState.grid[gridRow][gridCol];
                gridCell.filled = true;
                gridCell.pieceId = pieceId;
                gridCell.element.style.backgroundColor = piece.color;
                gridCell.element.textContent = cell.number; // ä¿æŒåŸæ¥çš„æ•°å­—
                gridCell.element.style.outline = ''; // æ¸…é™¤é¢„è§ˆçš„è¾¹æ¡†
            }
            
            // æ›´æ–°æ‹¼å›¾çŠ¶æ€
            piece.inGrid = true;
            piece.position = {
                row: row,
                col: col,
                minRow: minRow,
                minCol: minCol
            };
            
            // è®¾ç½®æ‹¼å›¾åœ¨ç½‘æ ¼ä¸­çš„ä½ç½® - ç¡®ä¿ç²¾ç¡®å®šä½
            const cellSize = 40; // ä¸CSSä¸­çš„å•å…ƒæ ¼å¤§å°ä¿æŒä¸€è‡´
            piece.element.style.position = 'absolute';
            piece.element.style.left = `${col * cellSize}px`;
            piece.element.style.top = `${row * cellSize}px`;
            piece.element.style.zIndex = '5'; // ç¡®ä¿ä½äºç½‘æ ¼å†…å•å…ƒæ ¼ä¹‹ä¸Š
            
            // ç¡®ä¿æ‹¼å›¾å…ƒç´ åœ¨ç½‘æ ¼ä¸­
            if (piece.element.parentElement !== elements.numberGrid) {
                elements.numberGrid.appendChild(piece.element);
            }
            
            // æ£€æŸ¥æ˜¯å¦æ­£ç¡®æ”¾ç½®
            checkCorrectPlacement(piece);
            
            // æ¸…é™¤ä¸´æ—¶å­˜å‚¨çš„ä½ç½®ä¿¡æ¯
            piece._lastPosition = null;
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å®Œæˆ
            checkGameCompletion();
            
            return true;
        }
        
        // å¦‚æœä¸èƒ½æ”¾ç½®ä½†ä¹‹å‰åœ¨ç½‘æ ¼ä¸­ï¼Œå°è¯•æ¢å¤åŸä½ç½®
        if (piece._lastPosition) {
            restorePieceInGrid(pieceId, piece._lastPosition);
        }
        
        // æ¸…é™¤ä¸´æ—¶å­˜å‚¨çš„ä½ç½®ä¿¡æ¯
        piece._lastPosition = null;
        return false;
    }

    // æ¢å¤æ‹¼å›¾åœ¨ç½‘æ ¼ä¸­çš„åŸä½ç½®
    function restorePieceInGrid(pieceId, position) {
        const piece = gameState.pieces[pieceId];
        const {row, col, minRow, minCol} = position;
        
        // é‡æ–°å¡«å……ç½‘æ ¼æ•°æ®å¹¶æ›´æ–°æ˜¾ç¤º
        for (const cell of piece.cells) {
            const relativeRow = cell.row - minRow;
            const relativeCol = cell.col - minCol;
            
            const gridRow = row + relativeRow;
            const gridCol = col + relativeCol;
            
            if (gridRow >= 0 && gridRow < 10 && gridCol >= 0 && gridCol < 10) {
                const gridCell = gameState.grid[gridRow][gridCol];
                gridCell.filled = true;
                gridCell.pieceId = pieceId;
                gridCell.element.style.backgroundColor = piece.color;
                gridCell.element.textContent = cell.number;
            }
        }
        
        // ç¡®ä¿æ‹¼å›¾DOMå…ƒç´ ä½ç½®æ­£ç¡®
        const cellSize = 40;
        piece.element.style.position = 'absolute';
        piece.element.style.left = `${col * cellSize}px`;
        piece.element.style.top = `${row * cellSize}px`;
        
        // æ›´æ–°æ‹¼å›¾çŠ¶æ€
        piece.inGrid = true;
        piece.position = position;
        
        // æ¢å¤æ£€æŸ¥æ˜¯å¦æ­£ç¡®æ”¾ç½®
        checkCorrectPlacement(piece);
    }

    // å¤„ç†æ‹–æ”¾ç»“æŸ
    function handleDrop(e) {
        e.preventDefault();
        
        if (gameState.currentDraggingPiece && gameState.isGameStarted) {
            // è·å–é¼ æ ‡ä½ç½®
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // è·å–ç½‘æ ¼å…ƒç´ çš„ä½ç½®
            const gridRect = elements.numberGrid.getBoundingClientRect();
            
            // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨ç½‘æ ¼å†…
            const isMouseInGrid = 
                mouseX >= gridRect.left && 
                mouseX < gridRect.right && 
                mouseY >= gridRect.top && 
                mouseY < gridRect.bottom;
                
            if (isMouseInGrid) {
                // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºç½‘æ ¼çš„ä½ç½®
                const relX = mouseX - gridRect.left;
                const relY = mouseY - gridRect.top;
                
                // è®¡ç®—å¯¹åº”çš„ç½‘æ ¼è¡Œåˆ—
                const cellSize = 40;
                const col = Math.floor(relX / cellSize);
                const row = Math.floor(relY / cellSize);
                
                // ç¡®ä¿targetRowå’ŒtargetColåœ¨åˆç†èŒƒå›´å†…ï¼ˆ0-9ï¼‰
                const targetRow = Math.max(0, Math.min(9, row));
                const targetCol = Math.max(0, Math.min(9, col));
                
                // ç›´æ¥å°è¯•æ”¾ç½®æ‹¼å›¾åˆ°è®¡ç®—å‡ºçš„ä½ç½®
                placePieceToGrid(gameState.currentDraggingPiece.id, targetRow, targetCol);
            } else {
                // å¦‚æœä¸åœ¨ç½‘æ ¼åŒºåŸŸï¼Œåˆ™å°†æ‹¼å›¾æ”¾å›åŸæ¥çš„ä½ç½®åŒºåŸŸ
                const piece = gameState.currentDraggingPiece;
                if (piece._lastPosition) {
                    restorePieceInGrid(piece.id, piece._lastPosition);
                    piece._lastPosition = null;
                } else if (piece.inGrid && piece.position) {
                    // å¦‚æœå·²ç»åœ¨ç½‘æ ¼ä¸­ï¼Œä¿æŒåŸä½ç½®
                    restorePieceInGrid(piece.id, piece.position);
                } else {
                    // ç§»å›æ‹¼å›¾åŒºåŸŸ
                    if (piece.element.parentElement !== elements.pieces) {
                        elements.pieces.appendChild(piece.element);
                    }
                    piece.element.style.position = '';
                    piece.element.style.left = '';
                    piece.element.style.top = '';
                    piece.element.style.zIndex = '';
                }
            }
        }
        
        // æ¸…é™¤é¢„è§ˆå’Œæ‹–åŠ¨çŠ¶æ€
        clearPiecePreview();
        gameState.currentDraggingPiece = null;
        
        // ç§»é™¤æ‰€æœ‰å•å…ƒæ ¼çš„é«˜äº®çŠ¶æ€
        document.querySelectorAll('.grid-cell.highlight').forEach(cell => {
            cell.classList.remove('highlight');
        });
    }

    // æ£€æŸ¥æ‹¼å›¾æ˜¯å¦æ­£ç¡®æ”¾ç½®
    function checkCorrectPlacement(piece, removing = false) {
        if (!piece.inGrid) return false;
        
        let isCorrect = true;
        const position = piece.position;
        
        for (const cell of piece.cells) {
            const gridRow = cell.row - position.minRow + position.row;
            const gridCol = cell.col - position.minCol + position.col;
            
            if (gridRow < 0 || gridRow >= 10 || gridCol < 0 || gridCol >= 10) {
                isCorrect = false;
                break;
            }
            
            const gridCell = gameState.grid[gridRow][gridCol];
            if (gridCell.number !== cell.number) {
                isCorrect = false;
                break;
            }
        }
        
        // æ›´æ–°æ­£ç¡®æ”¾ç½®è®¡æ•°
        if (isCorrect) {
            if (removing) {
                gameState.correctPlacements--;
            } else {
                // æ’­æ”¾æ­£ç¡®éŸ³æ•ˆ
                elements.correctSound.currentTime = 0;
                elements.correctSound.play();
                
                // å¢åŠ åˆ†æ•°
                updateScore(50);
                
                gameState.correctPlacements++;
            }
        }
        
        return isCorrect;
    }

    // æ›´æ–°åˆ†æ•°
    function updateScore(points) {
        gameState.score += points;
        elements.score.textContent = gameState.score;
    }

    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å®Œæˆ
    function checkGameCompletion() {
        // ç¡®ä¿ä¸€å…±æ­£ç¡®æ”¾ç½®äº†10ä¸ªæ‹¼å›¾æ‰ç®—æ¸¸æˆå®Œæˆ
        if (gameState.correctPlacements === 10) {
            gameCompleted();
        }
    }

    // æ¸¸æˆå®Œæˆå¤„ç†
    function gameCompleted() {
        gameState.isGameCompleted = true;
        clearInterval(gameState.timerInterval);
        
        // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
        elements.successSound.play();
        
        // æ˜¾ç¤ºçƒŸèŠ±ç‰¹æ•ˆ
        showFireworks();
        
        // æ˜¾ç¤ºç¥è´ºæ¨¡æ€æ¡†
        setTimeout(() => {
            elements.finalScore.textContent = gameState.score;
            elements.finalTime.textContent = elements.timer.textContent;
            elements.congratsModal.style.display = 'flex';
        }, 1500);
    }

    // æ˜¾ç¤ºçƒŸèŠ±ç‰¹æ•ˆ
    function showFireworks() {
        elements.fireworks.style.display = 'block';
        
        const createFirework = () => {
            const firework = document.createElement('div');
            firework.className = 'firework';
            firework.style.left = `${Math.random() * 100}%`;
            firework.style.top = `${Math.random() * 100}%`;
            firework.style.boxShadow = `0 0 8px 2px ${colors[Math.floor(Math.random() * colors.length)]}`;
            
            elements.fireworks.appendChild(firework);
            
            // åŠ¨ç”»ç»“æŸåç§»é™¤çƒŸèŠ±
            setTimeout(() => {
                firework.remove();
            }, 2000);
        };
        
        // åˆ›å»ºå¤šä¸ªçƒŸèŠ±
        for (let i = 0; i < 50; i++) {
            setTimeout(createFirework, i * 100);
        }
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
    document.addEventListener('DOMContentLoaded', initGame);

    // æ”¾ç½®æ‹¼å›¾çš„è¾…åŠ©å‡½æ•° - è¿™æ˜¯ä¹‹å‰ç¼ºå¤±ä½†åœ¨ä»£ç ä¸­å¼•ç”¨çš„å‡½æ•°
    function placePiece(piece, row, col) {
        if (!piece) return false;
        
        // ç›´æ¥è°ƒç”¨æ”¾ç½®æ‹¼å›¾åˆ°ç½‘æ ¼çš„å‡½æ•°
        return placePieceToGrid(piece.id, row, col);
    } 
    </script>
</body>
</html> 